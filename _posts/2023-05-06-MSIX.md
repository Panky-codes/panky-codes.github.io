---
layout: post
title: "Adding MSI(x) interrupt support to SerenityOS"
tags: os serenityos
---
Traditional PCI devices use a shared interrupt line to signal the CPU
when they need attention. This can lead to performance issues as all the
devices that are connected to the interrupt line need to invoke their
interrupt handler. Message Signalled Interrupts (MSI) was developed to 
address these problems by providing a more efficient and scalable way
of handling interrupts.

MSI were introduced as a part of PCI 2.2, and it works by allowing the
device to send an interrupt message directly to the CPU through the PCI
bus. When the CPU receives the message, it knows exactly which device
generated the interrupt and can handle it accordingly. This reduces
interrupt latency and helps to avoid conflicts between devices that share the same interrupt line.

The following image shows how E1000NetworkAdapter and NVMe device are
sharing the same interrupt line (10) when using the traditional pin-based
interrupts:

| ![IOAPIC \label{classdiag}](/assets/MSI/lsirq-IOAPIC.png) |
|:--:|
| E1000NetworkAdapter and NVMe sharing the same interrupt line |

MSI can solve this problem by not sharing the same interrupt line.
I decided add support for MSI<sup>1</sup> and MSIx<sup>2</sup> interrupt mechanism as SerenityOS was
lacking those features.

In pin-based interrupt mechanism, the driver reads the interrupt line
field in the PCI header and uses that to program the interrupt handler.
For MSI based interrupts, the driver has to program the device with an
IRQ number that it wants the device to trigger when an interrupt occurs.
As serenity always used pin-based interrupts, new APIs were introduced to
make MSI(x) work.

This article will be showing how the APIs are used by the driver and
explain how MSI(x) work in a more practical manner.
Not everything regarding MSI will be covered in this article. Please
check out the [osdev](https://wiki.osdev.org/PCI#Message_Signaled_Interrupts)
article and the [intel software manual](https://cdrdv2.intel.com/v1/dl/getContent/671200) chapter 11
before proceeding. Even though they were good documentation, I missed
some information which is what I will cover in this article.


To keep the article more practical, the following sections will introduce the new
APIs that were added to access the MSI(x) functionality and the
implementation of the API will be discussed.

# MSI(x) APIs
Two new APIS were added: `reserve_irqs` and `allocate_irq` as part of
the PCI device class.

```
ErrorOr<InterruptType> reserve_irqs(u8 number_of_irqs, bool msi);
ErrorOr<u8> allocate_irq(u8 index);
```

`reserve_irqs` takes two parameters: `number_of_irqs` and a boolean
`msi`.
`reserve_irqs` will reserve `number_of_irqs` IRQs for the driver. It will scan
through the interrupt handler list `s_interrupt_handler` in
`interrupts.cpp` to get a handler that is not used by any device, and
reserves a **contiguous** range of interrupt handler for the driver to
use. For now the API will return an error if it cannot find a contiguous
range of `number_of_irqs` IRQs. The second parameter `msi` will fallback
to pin-based interrupts if this is set to `false`. If `msi` is set to
true, the API will try to reserve `MSIx`(more about this later) over `MSI` interrupt mechanism.
Of course, if the driver does not support MSI(x), then the API will
resort to pin-based interrupts.

`allocate_irq` takes index as its parameter.

## MSI

The AHCI (`Kernel/Storage/ATA/AHCI/Controller.cpp`) driver has been
modified to use MSI. The following snippet shows how the MSI is
programmed by the controller:

```
UNMAP_AFTER_INIT ErrorOr<void> AHCIController::initialize_hba(...)
{
    ...
    TRY(reserve_irqs(1, true));
    auto irq = MUST(allocate_irq(0));
    ...
    m_irq_handler = TRY(AHCIInterruptHandler::create(*this, irq, implemented_ports));
    ...
}
```

## MSIx





<sup>1</sup> [Pull Request: MSI](https://github.com/SerenityOS/serenity/pull/18732). Check out MSIx PR<sup>2</sup> 
before seeing this PR as I added MSIx support first.

<sup>2</sup> [Pull Request: MSIx](https://github.com/SerenityOS/serenity/pull/18580)
