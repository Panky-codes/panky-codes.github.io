---
layout: post
title: Porting CHIP8 to an ESP32
tags: embedded-sw c++ 
---

I am really fascinated by how computers or a certain piece of electronic hardware work. Building emulators is an easy way to look under the veil of a piece of hardware or some processor using software. Of course it is not easy to develop an emulator for a modern day hardware as they are much more complex. One easy way to get started is to build an emulator for older hardware as processors used to be much simpler than what we have today in 2020. The best part is, some of the core concepts still remain the same.

Building a CHIP8 "emulator" is one of the very popular way of getting started with emulation programming. I put quotes around emulator in the previous sentence because CHIP8 is actually a virtual machine. The CHIP8 programming language( sort of the "Byte code" ) is used to write programs that target the CHIP8 virtual machine. As the CHIP8 virtual machine has opcodes(operation code) that are similar to modern processor instruction set and there are only small number of them, building the CHIP8 emulator is one of the best way to get started in the world of emulation.  

I wrote a [CHIP8](https://github.com/Panky-codes/CHIP8) emulator using C++17 with SFML to handle IO(input output) for desktop Linux. But this article is not about building a CHIP8 emulator for desktop. There are already plethora of articles(put link here) which does a much better job in explaining than what I could possibly do. I wanted a bit of extra challenge so I decided to port my existing CHIP8 emulator I wrote for desktop to a smaller, resource constrained microcontroller, ESP32. Some hardcore embedded folks might say ESP32 is not really resource constrained because of its 512 kB RAM and 4 MB flash, but compared to my laptop, an ESP32 is definitely resource constrained. ESP32 is very cheap and it comes with a built-in bluetooth low energy (BLE), which I will be using for giving inputs to my emulator. 

I will not go through each and every single detail on how to build an ESP32 based CHIP8 emulator in this article. But this article will give you the overall picture plus some of the issues I faced while building the emulator that might come in handy for someone deciding to build their own. This might be a fun project for someone who already has some basic experience with embedded system and looking to improve their skills with more advanced topics such BLE, RTOS, filesystems (FS), etc.

Let's get rolling!
## Prerequisites
### Hardware
- ESP32 DevKitC  (of course)
- ILI9341 based 2.4 inch 240x320 SPI TFT ([link](https://www.aliexpress.com/item/32956172798.html?spm=a2g0s.9042311.0.0.3cc44c4dJP5gvH))
- Bread board
- Jumper wires
- Android phone (Will be using an Android App(TODO give git link) as the Keyboard to interact with ESP32)
TODO: 
Connection table

### Software
**C++17** with the native **ESP-IDF** (based on FreeRTOS) framework is used to program the ESP32. It was definitely nice to use modern C++ to write the firmware. I decided not to use Arduino. Arduino is great to get started and to quickly prototype something, but probably not great if you want to learn what is going on underneath and have total control due to its abstraction model. The best way to learn embedded software is to create your own abstraction with the native SDK provided by the vendor. 

Bluetooth Low energy(BLE) is used to communicate with the ESP32. ESP-IDF comes with bluedroid based Bluetooth stack. The display driver for ILI9341 is based on this [repo](https://github.com/jeremyjh/ESP32_TFT_library). I made a fork of it because I had to adapt the code a bit. It is added as a submodule in my main repo.
#### Optional
I used Flutter SDK to develop the Android app. This is totally optional. You can use the android app I made to control the ESP32-CHIP8. 
It was definitely a lot of fun developing the android app as I have never developed one before. And, especially, it is really easy to quickly prototype something with Flutter.
## Implementation

| ![SW Class Diagram](/assets/ESP32-CHIP8/CHIP8_class.png) |
|:--:| 
| *Class diagram of the ESP32 CHIP8 system* |

The class diagram shown above roughly indicates different components and how they are related. The CHIP8 class in the diagram is sort of an orchestrator that glues different components together.

In the following subsections we will discuss about each class more in-depth.
### Virtual Machine (VM)

#### Concept
The VM class implements the core logic of CHIP8 VM in our system such as evaluating OPCODES. The [CHIP8](http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#2.0) has 4KB RAM and 16 of 8-bit general purpose registers. The registers and RAM are emulated by using `std::array`. The main job of a VM can be summarized as following:

| ![State Diagram](/assets/ESP32-CHIP8/VM_state.png) |
|:--:| 
| *Virtual Machine's state diagram* |

The `fetch` part retrieves the OPCODE from the RAM based on the current Program Counter. The `decode` part looks for the current OPCODE implementation, which in our case is a simple `switch` statement. The `execute` part just executes the implementation corresponding to that OPCODE.  

#### Porting
It was a bit surprising but I almost had no issues with this part when I ported from desktop to ESP32. But in a way it makes sense because the idea of having a VM is to have the portability across multiple platforms. I did have to change the debug print statements from using [fmt](https://github.com/fmtlib/fmt) in desktop to `ESP_LOG` functions for ESP32. But it was a very minor change.

The main takeaway is to **not introduce platform specific dependency** such as access to display, keyboard in this class for easy portability. 

### Keyboard

#### Concept
The original CHIP8 keyboard had a 16-key hexadecimal keypad to interact with the console.

#### Porting
In the desktop implementation I used SFML library to get the key that is pressed in the keyboard. But for ESP32, I decided to use Bluetooth Low Energy (more on this in the next section) as a way to give keyboard inputs. The `Keyboard` object runs in `core 1` and the `BLE` object runs in `core 0` of ESP32 and are created as part of different FreeRTOS tasks. So the easiest way to pass message between two tasks is using the [`FreeRTOS Queue`](https://www.freertos.org/a00018.html). The BLE class puts the value it receives via bluetooth on to a `queue` using `xQueueSend` function and the Keyboard class receives the value using `xQueueReceive` function.
### BLE
As indicated in the previous Keyboard subsection, BLE is used to give inputs to the ESP32-CHIP8 system. ESP32 will run a BLE GATT(Generic Attribute Profile) server. In [BLE terms](https://embedded.fm/blog/ble-roles), ESP32 will act as a `peripheral` that advertises itself to be connected to a `central` (our smartphone in this case). 

Making BLE work took me the most time in this complete project as I had zero experience with it before and I didn't want to use any third-party library for it. There is a third-party [library](https://github.com/nkolban/esp32-snippets) by Neil Kolban if you don't want to write your own GATT server. But in case you are starting the BLE journey from scratch like me, writing a simple GATT server would definitely be a nice way to understand some basics about it. The following are some of the articles/videos that helped me in learning the basics about BLE:

- [ESP32 gatt server example](https://github.com/espressif/esp-idf/blob/master/examples/bluetooth/bluedroid/ble/gatt_server/tutorial/Gatt_Server_Example_Walkthrough.md)
- [Introuction to Bluetooth Low Energy](https://learn.adafruit.com/introduction-to-bluetooth-low-energy/introduction)
- [All about ESP32 - BLE basics](https://atadiat.com/en/e-all-about-esp32-part-4/)
- [Introduction to BLE with Nordic semiconductors](https://www.youtube.com/watch?v=5TxUnbsHsR8&list=PLx_tBuQ_KSqE_Eyrg7ogzX33DWJDiq_AZ&index=12)
- [Blob is a good word (Embedded.fm podcast)](https://embedded.fm/episodes/232?rq=BLE)

The important thing about BLE stack is that, everything works on callbacks. This is something that took me sometime to wrap my head around. So, whenever a `central` writes to the `peripheral`(ESP32), a callback is called with a write event which contains the value that was written. As ESP32 has two cores and has a RTOS, these asynchronous events are gracefully handled. So whenever a value is written to ESP32 BLE server, the `BLE` class object will push that value to a FreeRTOS queue that will be used by the `Keyboard` class later. A simple sequence diagram of that flow is shown below:

| ![Sequence Diagram](/assets/ESP32-CHIP8/BLE_seq.png) |
|:--:| 
| *BLE and Keyboard class sequence diagram* |

### Display
### Filesystem
### CHIP8
### Discarded
Computers are fascinating. Processors are at the heart of the computer. They are one of the most important piece of hardware that are making the computer faster and getting smaller every year[moore's law]. With advancement in processor technology, comes the complexity. It is not easy to 
It all boils down to this fetch - decode - execute cycle. 
A CHIP8 ROM (the binary that contains a chip8 game) is copied on to the CHIP8 RAM starting from the address 0x200

One possible idea is to segregate between `concept` and `surprises while porting`
So the Keyboard class(as shown in the class diagram) gets the input via a `FreeRTOS Queue` that is created by the BLE class.

CHIP8 is a very primitive system that does not have a concept of interrupts. So polling takes place every cycle to check if any key is pressed. This leads to different outcomes for system based on buttons attached to the emulator vs the systems where the key pressed data is sent via BLE. When we press a button, the button press lasts for a time that is enough to be detected via polling. But if the data is sent out via BLE, the data might
