---
layout: post
title: But I was helping the compiler!
tags: c++ programming
---

Compilers are getting smarter and smarter everyday. [TBR]And, thanks to the fierce competition by Clang, GCC have also gotten better a lot in the recent past. If you don't believe me, write a piece code and check the assembly output for different versions of the same compiler (can be easily done via [compiler explore](https://godbolt.org/)). I have gotten in to the practice of checking the assembly output nowadays to analyze the overhead of various implementations. Beware, sometimes it can get really addictive. But, I think it is a nice way of learning to read assembly, and also be amazed on how clever the compilers are these days. 

In this article, I am going to cover one such incident that happened when I was looking at the assembly output of a function during my [CHIP8](https://github.com/Panky-codes/CHIP8) implementation. 

## The magic of move semantics
Move semantics was introduced in C++11. We can think of move semantics as a way of transferring ownership of an object. If you are really new to move semantics, consider the following example:

So your colleague has a document that you also want. We have two options of going about it. First option, you take that document to a copier, take a copy of the document for yourself, and return back the original document to your colleague. Second option, assuming your colleague doesn't really need the document anymore, instead of throwing it away, your colleague can give it to you, thereby, saving paper.  

Replace the document with a memory resource in a program, then the first option is doing a copy, and the second option is doing a move, where you transfer the ownership instead of wasting the resource. 
## Putting what I learned in action
While implementing my [CHIP8](https://github.com/Panky-codes/CHIP8) emulator, I saw an opportunity to replace an expensive copy operation into a cheap move operation (at least that is what I thought). 

To give a bit of context: In each frame cycle, I had to return an array containing 2048 integers that will be used to draw the graphics on the screen. The pseudo C++ code is shown below:

```cpp
// chip8.cpp
static constexpr display_size = 32;
class Chip8 {
    ... 
    public : 
        std::array<uint8_t, display_size> get_display_pixels() {
              // Do some computation
              return gfx;
          }
    ... 
    private : 
        std::array<uint8_t, display_size> gfx{};
};

// main.cpp
while (displayOn) {
    ... 
    const auto disp_pixels = emulator.get_display_pixels();
    ...
    // Use disp_pixels to draw pixels on the screen
}
``` 

This is what I assumed was going on when I did the call to `get_display_pixels()` member function:
  1.  Compiler `copies` the `gfx` private variable of the `Chip8` class to the return value of the `get_display_pixels()` member function.
  1.  Compiler calls the `copy constructor` to copy the return value of the function call to the `disp_pixels` variable.

So, I came to the conclusion that I could use a `move constructor` to transfer the contents to my local variable `disp_pixels` to avoid a copy in the second step as described above.  

So I changed my code in the `main` function as follows:
```cpp
// main.cpp
while (displayOn) {
    ... 
    const auto disp_pixels = std::move(emulator.get_display_pixels());
    ...
    // Use disp_pixels to draw pixels on the screen
}
```

(Before you get furious and stop reading the article further because what I assumed was completely wrong, I realized that too, and rest of the article is about that.)

As soon as I used a `std::move` as shown in my previous code snippet, I observed the compiler was generating more assembly code than my initial code without a `std::move`(with std::move: [link](https://godbolt.org/z/WulpDX), without std::move: [link](https://godbolt.org/z/oU8Tq4)).

What went wrong? ....
## NRVO to the rescue
NRVO stands for Named Return Value Optimization. It is a nice trick that the compiler uses to omit unnecessary copy or move, if certain conditions are met. Compilers have been using this trick for a long time and it has been guaranteed since `C++17`. If `NRVO` takes place in our function call, then effectively we just do one copy instead of two. Let's see how it works.

Even though the function signature of `get_display_pixels` indicates that it does not take any parameters, the compiler will pass one extra parameter behind the scenes from the caller (initialization call of `disp_pixels` from `main.cpp`) to the callee (`get_display_pixels` function in `chip8.cpp`). The caller will allocate the memory for the return value and pass the address of that memory to the callee. The callee will use that memory to construct the object and copy the value of the private variable `gfx` (in this case). As the memory of the caller (`disp_pixels`) was used by the callee, there is no need to copy the return value again, thereby, saving one unnecessary copy/move operation. 

We should see the assembly output to really understand how RVO is happening under the hood. The assembly code from the caller side is as follows:
```cpp
1   lea  rax, [rbp-64]
2   lea  rdx, [rbp-32]
3   mov  rsi, rdx
4   mov  rdi, rax
5   call Chip8::get_display_pixels()
``` 
Before the function call, `rsi` and `rdi` registers are loaded with upper and lower bound of the memory address of `disp_pixels` variable. And, the trimmed assembly output from the callee side is as follows:

```cpp
1   Chip8::get_display_pixels():
2   push rbp
3   mov  rbp, rsp
4   mov  QWORD PTR [rbp-8], rdi
5   mov  QWORD PTR [rbp-16], rsi
...
```
As seen from the callee side, the `rdi` and `rsi` values are moved to the stack, and further operations are performed with that memory address. Pretty neat!

A `simple analogy` for RVO I like to think of is when you are asking a friend to fill in water inside a water bottle, you would give your bottle to fill water from the tap directly. It would be inefficient to first fill the water in a temporary bottle and transfer the contents again to your bottle. In C++ context, `bottle` is the `memory space` and the `water` it holds is the `return value`.

As I am using `C++17` in which `NRVO` is guaranteed, the most efficient way of writing my function call is:
```cpp
// main.cpp
while (displayOn) {
    ... 
    const auto disp_pixels = emulator.get_display_pixels();
    ...
    // Use disp_pixels to draw pixels on the screen
}
```
GCC and Clang even have an extra warning flag `-Wpessimizing-move` which detects when we are trying to use a `move` where compiler generated NRVO is much more efficient.

But if `NRVO` is not taking place, should we use a `std::move` to convert the second copy into a move?
## Temporaries are Rvalues
If you are using a pre C++17 standard in your code, can we trust the compiler to perform NRVO even though it is not guaranteed? Or as I did before, should we explicitly indicate a move operation to save a copy just in case the compiler doesn't do a NRVO? To answer that, I enabled C++14 to the same code. And, it generated the same assembly code as C++17 with NRVO. In most cases we can assume NRVO to happen even for pre C++17 code. 

But there is a flag `-fno-elide-constructors` that disables copy elision (the super-set of NRVO) in our code, thereby, allowing to see what the compiler does otherwise. This is what we wanted to simulate a scenario where the compiler fails to apply NRVO so that we can check whether we needed to do something extra to avoid superfluous copies.

So I added `-fno-elide-constructors` to disable any NRVO to the final code of the previous section. The caller generated the following assembly code:

```cpp
1   lea  rax, [rbp-32]
2   lea  rdx, [rbp-64]
3   mov  rsi, rdx
4   mov  rdi, rax
5   call Chip8::get_display()
6   lea  rdx, [rbp-32]
7   lea  rax, [rbp-96]
8   mov  rsi, rdx
9   mov  rdi, rax
10  call std::array<unsigned char, 32ul>::array(std::array<unsigned char, 32ul>&&)
```

As we can notice, the first 5 assembly instructions are exactly the same as the version with NRVO enabled, and there are 5 more assembly instructions in this version as we disabled NRVO. The most important instruction we need to focus on is line number 10 where a `move constructor`(notice `&&` in the function signature). Wait, a `move constructor` is invoked? I did not use a `std::move` but compiler decided to do it anyway. I already gave away the reason as the title of this section but I will repeat it again: `Temporaries are Rvalues`.

[Here](https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c) you can find more about lvalues and rvalues in C++. In brief, quoting from that article: "rvalue is an expression that does not represent an object occupying some identifiable location in memory.". Let's get back to our original example and analyze why the move constructor was implicitly called. 

```cpp
// main.cpp
while (displayOn) {
    ... 
    const auto disp_pixels = emulator.get_display_pixels();
    ...
    // Use disp_pixels to draw pixels on the screen
}
```
In the above code snippet, the function call to `get_display_pixels` generates a temporary that is being used to construct the `disp_pixels` variable. As the temporary is a `rvalue`, compiler is smart enough to implicitly match it with the move constructor that takes in `rvalue reference` as its input. 
## Conclusion
In conclusion, whenever you learn a new concept, especially in C++, check the assembly that it generates to really verify what is happening, and what you expected to have happened. Trust me, learning a bit of assembly will definitely pay off because it let's us peek into what is ultimately going to run in the computer. 

I really thought move semantics worked a certain way and I started prematurely optimizing (pessimizing in this case) without really understanding them in a broader context. Looking into the assembly definitely deepened my understanding of move semantics.

Above all, I am starting trust the compiler to do the right thing for me and respect the compiler writers even more. Definitely check out this [video](https://www.youtube.com/watch?v=w0sz5WbS5AM) by Matt Godbolt that really stresses the point I am trying to make here.

Hope you enjoyed the article. Happy coding!

<sup>1</sup>Alternatively we could define a Concept without requires clause as follows:
